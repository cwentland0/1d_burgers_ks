# Finite Difference Solver for the Viscous Burgers' and Kuramoto-Sivashinsky Equations
Original code written by Christopher Wentland (University of Michigan) in August 2019

# Running the program
To run the program, first examine the settings in `driver.py`. This function contains all the necessary simulation parameters to define the governing equations, spatiotemporal discretizations, solution sampling, etc. Once the input parameters are properly defined, simply execute the command: `python3 ./driver.py`. This will execute the solver and finish by writing the time evolution of the solution to the disk.

# Code structure
### `driver.py`
Defines most of the inputs for computing the approximate solution of the Burgers' equation or K-S equation. Generates necessary subdirectories for data/restart file/image storage, sets all necessary input values, and then calls the FOM solver.

### `spaceSchemes.py`
Contains functions necessary for computing quantities related to the spatial discretization of the governing equation. This includes computing the initial conditions, precomputing the linear operator associated with the linear second- and fourth-order spatial derivative terms, computing the non-linear advection term, and computing the Jacobian of the RHS function.

### `timeSchemes.py`
Contains functions necessary for computing quantities associated with advancing the solution in time, i.e. the temporal discretization. 

### `onlineFuncs.py`
Contains the approximate solution solver. Organizes initial conditions from scratch or restart file, calls time-stepping functions, stores solution and RHS function and saves it to disk, and plots time evolution of the solution.

# Input notes and expanding the code
Almost all simulation inputs are included in `driver.py`. The only exceptions are those inputs dealing with convergence of the BDF schemes. These can be found in `timeSchemes.storeTimeDiffParams()`, named `maxIterations` and `residualTolerance`. Explanations for all inputs are included in in-line comments.

Adding new spatial/temporal difference schemes or initial conditions is relatively simple. 

For initial conditions, add a new conditional statement in `spaceSchemes.setICs()` corresponding to an appropriate input for `ICType`. Compute a value of `u0` for each point in the spatial domain `x`.

For spatial schemes, there are two types of schemes: the nonlinear advection term and the linear second- and fourth-order spatial derivative terms. For the nonlinear advection term, the means of producing a new scheme follows that of the initial conditions. Simply add new conditional statements in `spaceSchemes.computeNonlinRHS()` for appropriate input values of `nonlinDiffScheme` and `nonlinOrdAcc`. Then, compute a value for the discretized non-linear term as a function of `u`.

New temporal schemes are a bit more involved, as they require advancing the solution `u` and returning this to the main solver function, `onlineFuncs.computeFOM()`. Again, add a conditional statement in `onlineFuncs.computeFOM()` for an appropraite input value of `timeDiffScheme`, and add a new time-stepping funciton in `timeSchemes.py` which is called by `computeFOM()`. Ultimately, the scheme must return only the solution `u` at the next time step and the value of the RHS function evaluated at `u`, `RHS`.

# Restart files
Sometimes it is preferred to restart a simulation from a point in time for which we already have the solution, opposed to starting the simulation from scratch. This is particularly useful for the K-S equation, which generally involves large time-evolutions. Additionally, we generally only care about the solution once it is on the attractor. For this, we use restart files, which must be manually generated by the user. This only involves saving the solution at the desired point in time and its corresponding time-stepping iteration to another file. The following example code provides a method for performing this operation. In this case, we desire to restart the simulation from `t = 60`. For `dt = 1e-2` and `sampRate = 10`, this corresponds to sample 600. Note that `sampRate` must be identical between the original simulation and the restarted simulation to properly calculate the simulation iteration.

```python
import numpy as np
fullSol = np.load('./Data/u_ks_0.0_to_60.0_FOM')
restartSol = np.append(fullSol[599,:],600)
np.save('./RestartFiles/restart_from_60.npy',restartSol)
```

Once this restart file is saved, the simulation may be restarted from this solution by setting `restartFlag = True` and `restartFile = restart_from_60`. Obviously, you may use your own naming convention for the restart file name.

# Example cases
For all cases below, the following settings are fixed: `N = 512`, `xi = 0`, `restartFlag = False`, `sampRate = 10` 

### Burgers' sine wave, `problem = 'burgers'`
This is simply a sine wave which develops a standing shock at x = pi. Over time, the shock will slowly dissipate.

```python
timeDiffScheme = 'RK'
timeOrdAcc = 4
nonlinDiffScheme = 'upwind'
nonlinOrdAcc = 1
linOrdAcc = 2
xf = 2.*math.pi
ICType = 'sin'
angFreq = '1.'
tEnd = 2.
dt = 1.e-3
viscosity = 5.e-3

### Kuramoto-Sivashinsky chaos, `problem = 'ks'`
This problem displays how smooth initial conditions with relatively small magnitude will eventually develop bounded, large-magnitude, small scale fluctuations. Although the fluctuations appear random, the K-S equation is entirely deterministic. However, the solution is extremely sensitive to small perturbations in the initial conditions. If you would like to test this, simply add a small amount of random noise to the initial conditions (on the order of 1e-8) and observe how the final solution differs after a long time period.

Note that this equation produces an extremely stiff linear system and generally requires an implicit time stepping solution to solve in a reasonable amount of time. You are welcome to use the Runge-Kutta scheme, but it will require an extremely small time step to ensure numerical stability.

```python
timeDiffScheme = 'BDF'
timeOrdAcc = 2
nonlinDiffScheme = 'central'
nonlinOrdAcc = 2
linOrdAcc = 2
xf = 32.*math.pi
ICType = 'mixedSinCos'
angFreq = '1./16.'
tEnd = 150.
dt = 1.e-2
viscosity = 1.
```




